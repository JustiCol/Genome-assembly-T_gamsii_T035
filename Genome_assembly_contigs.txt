#!/bin/bash

###############################################################################
# SLURM job submission script: Genome assembly and polishing with Flye & Racon
###############################################################################

# SLURM options
#SBATCH --job-name=Genome_Assembly_T_gamsii
#SBATCH --cpus-per-task=10
#SBATCH --mem=40G
#SBATCH --output=reports/%j-%x.out
##SBATCH --mail-user=your.email@domain
##SBATCH --mail-type=ALL

###############################################################################
# Conda environment setup
###############################################################################
eval "$(conda shell.bash hook)"
source /path/to/miniconda3/etc/profile.d/conda.sh
conda activate genome_assembly_env

# Fail on errors or undefined variables
set -euo pipefail

###############################################################################
# Input/output paths
###############################################################################
WORKDIR="/path/to/workdir/T_gamsii"
REF="/path/to/reference/GCF_001481775.2_TGAM01v2_genomic.fna"
SHORT_READS_ZIP="/path/to/raw_data/barcode34.zip"
LONG_READS_ZIP="/path/to/raw_data/barcode34_long.zip"

mkdir -p "$WORKDIR"
cd "$WORKDIR"

###############################################################################
# Unzip and combine reads
###############################################################################
echo "Unzipping and combining reads..."
unzip -o "$SHORT_READS_ZIP" -d short_reads
unzip -o "$LONG_READS_ZIP" -d long_reads
cat long_reads/barcode34/*.fastq.gz /path/to/extra_long_reads/*.fastq.gz short_reads/barcode34/*.fastq.gz > long_reads_combined.fastq.gz

###############################################################################
# Filter and QC long reads
###############################################################################
echo "Filtering long reads..."
zcat long_reads_combined.fastq.gz | NanoFilt -q 10 -l 1000 > long_reads_clean.fastq

NanoStat --fastq long_reads_clean.fastq -n myRun_readpool_Tg --outdir stats_nanostat
NanoPlot --fastq long_reads_clean.fastq --outdir nanoplot_results --plots kde dot

###############################################################################
# Assemble genome with Flye
###############################################################################
echo "Running Flye..."
flye --nano-raw long_reads_clean.fastq --out-dir flye_assembly --genome-size 31m --threads 10 --iterations 3
cp flye_assembly/assembly.fasta flye_raw.fasta

###############################################################################
# Racon polishing
###############################################################################
echo "Polishing with Racon..."
cp flye_raw.fasta racon0.fasta
for i in 1 2 3; do
    minimap2 -ax map-ont racon$((i-1)).fasta long_reads_clean.fastq > racon${i}.sam
    racon -t 10 long_reads_clean.fastq racon${i}.sam racon$((i-1)).fasta > racon${i}.fasta
done

###############################################################################
# Assembly evaluation with QUAST and BUSCO
###############################################################################
echo "Running QUAST..."
quast.py -o quast_flye -r "$REF" flye_raw.fasta
quast.py -o quast_racon -r "$REF" racon3.fasta

echo "Running BUSCO..."
BUSCO_LINEAGE="/path/to/busco_lineages/fungi_odb10"
busco -i flye_raw.fasta -l "$BUSCO_LINEAGE" -o busco_flye -m genome -c 10
busco -i racon3.fasta -l "$BUSCO_LINEAGE" -o busco_racon -m genome -c 10
busco -i "$REF" -l "$BUSCO_LINEAGE" -o busco_reference -m genome -c 10

###############################################################################
# Assembly statistics summary
###############################################################################
echo "Computing assembly stats..."
seqkit stats flye_raw.fasta > stats_flye.txt
seqkit stats racon3.fasta > stats_racon.txt

echo "Generating summary.csv..."
echo "METHOD;N50;TOTAL_LENGTH;N_CONTIGS;BUSCO_COMPLETE;BUSCO_FRAGMENTED;BUSCO_MISSING" > summary.csv

for method in racon reference; do
    if [ "$method" = "reference" ]; then
        quast_dir="quast_reference"
        busco_dir="busco_reference"
        assembly="$REF"
    else
        quast_dir="quast_${method}"
        busco_dir="busco_${method}"
        assembly="${method}3.fasta"
    fi

    if [ -f "${quast_dir}/report.txt" ]; then
        N50=$(grep "^N50" ${quast_dir}/report.txt | awk '{print $2}')
        SIZE=$(grep "^Total length" ${quast_dir}/report.txt | head -n1 | awk '{print $3}')
        NCONTIG=$(grep "^Number of contigs" ${quast_dir}/report.txt | head -n1 | awk '{print $4}')
    else
        N50="NA"; SIZE="NA"; NCONTIG="NA"
    fi

    BUSCO_FILE=$(ls ${busco_dir}/short_summary*.txt 2>/dev/null | head -n1)
    if [ -f "$BUSCO_FILE" ]; then
        C=$(grep "Complete BUSCOs" "$BUSCO_FILE" | awk '{print $1}')
        F=$(grep "Fragmented BUSCOs" "$BUSCO_FILE" | awk '{print $1}')
        M=$(grep "Missing BUSCOs" "$BUSCO_FILE" | awk '{print $1}')
    else
        C="NA"; F="NA"; M="NA"
    fi

    echo "${method^^};${N50};${SIZE};${NCONTIG};${C};${F};${M}" >> summary.csv
done

echo "Résumé écrit dans summary.csv"

echo "SLURM job ID: $SLURM_JOB_ID"
sacct -j "$SLURM_JOB_ID" --format=JobID,JobName,Elapsed,TotalCPU,MaxRSS

echo "Job completed successfully."
